#' @title  Plot a set of satellite image time series
#' @name   sits_plot
#' @author Gilberto Camara, \email{gilberto.camara@@inpe.br}
#' @description Given a sits tibble with a set of time series, plot them.
#'
#' The plot function produces different plots based on the input data:
#' \itemize{
#'  \item{"all years": }{Plot all samples from the same location together}
#'  \item{"patterns": }{Plot the patterns for a given set of classes}
#'  \item{"together": }{Plot all samples of the same band and label together}
#'  \item{"classification": }{Plot the results of a classification}
#' }
#' The sits_plot function makes an educated guess of what plot is required,
#' based on the input data. If the input data has less than 30 samples, it
#' will default to "all years". If there is only one sample per class, it will
#' default to "patterns". If there are more than 30 samples, it will default to
#' "together". If the input data has predicted values resulting from a classification, it will
#' plot the classification. To plot a classified raster image,
#' please use \code{\link[sits]{sits_plot_raster}}.
#'
#'
#' @param  data          Data to be plotted (can be a sits tibble, clusters, or TWDTW matches).
#' @param  band          The band used for visualisation (optional for sits_plot_classification).
#' @param  colors        Color pallete to be used (based on Color Brewer - default is "Dark2").
#' @return Input sits tibble (useful for chaining functions).
#'
#' @examples
#' \donttest{
#' # Read a set of samples with 2 classes ("Cerrado" and "Pasture")
#' data ("cerrado_2classes")
#' # Plot all the samples together
#' sits_plot (cerrado_2classes)
#' # Plot the first 20 samples (defaults to "allyears")
#' sits_plot (cerrado_2classes[1:20,])
#' # Plot the patterns
#' sits_plot (sits_patterns(cerrado_2classes))
#' # Retrieve the set of samples for the Mato Grosso region (provided by EMBRAPA)
#' data(samples_mt_ndvi)
#' # Retrieve a point
#' data(point_ndvi)
#' # classify the point
#' model_svm <- sits_train(samples_mt_ndvi, ml_method = sits_svm())
#' class_ndvi.tb <-  sits_classify (point_ndvi, model_svm)
#' # plot the classification
#' sits_plot (class_ndvi.tb)
#' }
#' @export
sits_plot <- function(data, band = "ndvi", colors = "Dark2") {
    # backward compatibility
    if ("coverage" %in% names(data))
        data <- .sits_tibble_rename(data)
    # is the input a dendrogram"
    if ("dtwclust" %in% class(data))
        stop("input is a set of clusters generated by sits_dendrogram \n please use sits_plot_dendrogram")
    if ("twdtwMatches" %in% class(data))
        .sits_plot_twdtw_alignments(data)

    # try to guess what is the plot type
    if ("time_series" %in% names(data)) {
        # is there only one sample per label? Plot patterns!
        if (max(sits_labels(data)$count) == 1 && nrow(data) > 1)
            .sits_plot_patterns(data)
        # Both data and prediction exist? Plot classification!
        else if ("predicted" %in% names(data)) {
            .sits_plot_classification(data, band = band)
        }
        # Are there more than 30 samples? Plot them together!
        else if (nrow(data) > 30) {
            .sits_plot_together(data, colors)
        }
        # If no conditions are met, take "allyears" as the default
        else
            .sits_plot_allyears(data, colors)
    }
    # return the original sits tibble - useful for chaining
    return(invisible(data))
}

#' @title Plot all time intervals of one time series for the same lat/long together
#' @name .sits_plot_allyears
#'
#' @description For each lat/long location in the data, join temporal
#' instances of the same place together for plotting.
#' @param data    One or more time series (stored in a sits tibble).
#' @param colors  The color pallete to be used (default is "Set2").
.sits_plot_allyears <- function(data, colors) {
    locs <- dplyr::distinct(data, longitude, latitude)

     purrr::pmap(list(locs$longitude, locs$latitude), function(long, lat) {
         dplyr::filter(data, longitude == long, latitude == lat) %>%
             .sits_ggplot_series(colors) %>%
             graphics::plot()
    })
}

#' @title Plot classification results
#' @name .sits_plot_classification
#' @author Victor Maus, \email{vwmaus1@@gmail.com}
#' @description        Plots the classification results (code reused from the dtwSat package by Victor Maus).
#' @param data         A sits tibble with one or more time series that have been classified.
#' @param band         Band for plotting the classification.
.sits_plot_classification <- function(data, band = NULL) {
    if (purrr::is_null(band))
        band <- sits_bands(data)[1]

    # prepare a data frame for plotting

    #get the labels
    labels <- sits_labels(data)$label

    # put the time series in the data frame
    purrr::pmap(list(data$latitude, data$longitude, data$label,
                     data$time_series, data$predicted),
                function(row_latitude, row_longitude, row_label,
                          row_time_series, row_predicted) {
                    lb = .sits_plot_title(row_latitude, row_longitude, row_label)
                    # extract the time series
                    ts <- row_time_series
                    # convert to data frame
                    df.x <- data.frame(Time = ts$Index, ts[,band], Series = as.factor(lb))
                    # melt the time series data for plotting
                    df.x <- reshape2::melt(df.x, id.vars = c("Time", "Series"))
                    # define a nice set of breaks for value plotting
                    y.labels = scales::pretty_breaks()(range(df.x$value, na.rm = TRUE))
                    y.breaks = y.labels

                    # get the predicted values as a tibble

                    pred <- row_predicted
                    df.pol <- data.frame()

                    # create a data frame with the predicted values and time intervals
                    i <- 1
                    purrr::pmap(list(row_predicted$from, row_predicted$to,
                                     row_predicted$class),
                                function (rp_from, rp_to, rp_class) {

                                    best_class <- as.character(rp_class)

                                    df.p <- data.frame(
                                        Time  = c(lubridate::as_date(rp_from), lubridate::as_date(rp_to),
                                                  lubridate::as_date(rp_to), lubridate::as_date(rp_from)),
                                        Group = rep(i, 4),
                                        Class = rep(best_class, 4),
                                        value = rep(range(y.breaks, na.rm = TRUE), each = 2)
                                    )
                                    i <<- i + 1
                                    df.pol <<- rbind(df.pol, df.p)

                                })

                    df.pol$Group  <-  factor(df.pol$Group)
                    df.pol$Class  <-  factor(df.pol$Class)
                    df.pol$Series <-  rep(lb, length(df.pol$Time))

                    I = min(df.pol$Time, na.rm = TRUE) - 30 <= df.x$Time &
                        df.x$Time <= max(df.pol$Time, na.rm = TRUE) + 30

                    df.x = df.x[I,,drop = FALSE]

                    gp <-  ggplot2::ggplot() +
                        ggplot2::facet_wrap(~Series, scales = "free_x", ncol = 1) +
                        ggplot2::geom_polygon(data = df.pol,
                                              ggplot2::aes_string(x = 'Time', y = 'value', group = 'Group', fill = 'Class'),
                                              alpha = .7) +
                        ggplot2::scale_fill_brewer(palette = "Set3") +
                        ggplot2::geom_line(data = df.x, ggplot2::aes_string(x = 'Time', y = 'value', colour = 'variable')) +
                        ggplot2::scale_y_continuous(expand = c(0, 0), breaks = y.breaks, labels = y.labels) +
                        ggplot2::scale_x_date(breaks = ggplot2::waiver(), labels = ggplot2::waiver()) +
                        ggplot2::theme(legend.position = "bottom") +
                        ggplot2::guides(colour = ggplot2::guide_legend(title = "Bands")) +
                        ggplot2::ylab("Value") +
                        ggplot2::xlab("Time")

                    graphics::plot(gp)

                })
    return(invisible(data))
}

#' @title Plot classification patterns
#' @name .sits_plot_patterns
#' @author Victor Maus, \email{vwmaus1@@gmail.com}
#' @description Plots the patterns to be used for classification
#'              this code is reused from the dtwSat package by Victor Maus.
#' @param data.tb One or more time series containing patterns (stored in a sits tibble).
.sits_plot_patterns <- function(data.tb) {
    # prepare a data frame for plotting
    plot.df <- data.frame()

    # put the time series in the data frame
    purrr::pmap(list(data.tb$label, data.tb$time_series),
                     function(label, ts) {
                         lb = as.character(label)
                         # extract the time series and convert
                         df <- data.frame(Time = ts$Index, ts[-1], Pattern = lb)
                         plot.df <<- rbind(plot.df, df)
    })

    plot.df <- reshape2::melt(plot.df, id.vars = c("Time", "Pattern"))

    # Plot temporal patterns
    gp <-  ggplot2::ggplot(plot.df, ggplot2::aes_string(x = "Time", y = "value", colour = "variable") ) +
        ggplot2::geom_line() +
        ggplot2::facet_wrap(~Pattern) +
        ggplot2::theme(legend.position = "bottom") +
        ggplot2::scale_x_date(labels = scales::date_format("%b")) +
        ggplot2::guides(colour = ggplot2::guide_legend(title = "Bands")) +
        ggplot2::ylab("Value")

    graphics::plot(gp)

    return(invisible(data.tb))
}

#' @title Plot a set of time series for the same spatio-temporal reference
#'
#' @name .sits_plot_together
#'
#' @description Plots all time series for the same label together.
#' This function is useful to find out the spread of the values of the time serie
#' for a given label.
#'
#' @param    data.tb    A sits tibble with the list of time series to be plotted.
#' @param    colors     The color pallete to be used (default is "Set1").
#' @return The input sits tibble (useful for chaining functions).
.sits_plot_together <- function(data.tb, colors) {
    # create a data frame with the median, and 25% and 75% quantiles
    create_IQR <- function(DT, band) {
        data.table::setnames(DT, band, "V1")
        DT_med <- DT[,stats::median(V1), by = Index]
        data.table::setnames(DT_med,"V1", "med")
        DT_qt25 <- DT[,stats::quantile(V1, 0.25), by = Index]
        data.table::setnames(DT_qt25,"V1", "qt25")
        DT_qt75 <- DT[,stats::quantile(V1, 0.75), by = Index]
        data.table::setnames(DT_qt75,"V1", "qt75")
        DT_qts <- merge(DT_med, DT_qt25)
        DT_qts <- merge(DT_qts, DT_qt75)
        data.table::setnames(DT, "V1", band)
        return(DT_qts)
    }
    # this function plots all the values of all time series together (for one band)
    plot_samples <- function(DT, DT_qts, band, label, number) {
        # melt the data into long format (required for ggplot to work)
        DT_melted <- data.table::melt(DT, id.vars = "Index")
        # make the plot title
        title <- paste("Samples (", number, ") for class ", label, " in band = ", band, sep = "")
        # plot all data together
        g <- .sits_ggplot_together(DT_melted, DT_qts, title)
        graphics::plot(g)
    }

    # how many different labels are there?
    labels <- sits_labels(data.tb)$label

    labels %>%
        purrr::map(function(l) {
            lb = as.character(l)
            # filter only those rows with the same label
            data2.tb <- dplyr::filter(data.tb, label == lb)
            # how many time series are to be plotted?
            number <- nrow(data2.tb)
            # what are the band names?
            bands  <- sits_bands(data2.tb)
            # what are the reference dates?
            ref_dates <- sits_time_series_dates(data2.tb)
            # align all time series to the same dates
            data2.tb <- sits_align(data2.tb, ref_dates)
            # extract the time series
            #DT <- data.table::data.table(dplyr::bind_rows(data2.tb$time_series))

            bands %>%
                purrr::map(function(band) {
                    # select the band to be shown
                    band.tb <- .sits_select_bands_(data2.tb, band)
                    # create a list with all time series for this band
                    DT.lst <- purrr::map(band.tb$time_series, function(ts) {data.table::data.table(ts) })
                    # set "Index" as the key for all data.tables in the list
                    DT.lst <- purrr::map(DT.lst, function(dt) {data.table::setkey(dt, Index)})
                    # rename the columns of the data table prior to merging
                    for (i in 1:length(DT.lst))
                        data.table::setnames(DT.lst[[i]],band,paste0(band, ".", as.character(i)))
                    # merge the list of data.tables into a single table
                    DT <- Reduce(function(...) merge(..., all = T), DT.lst)

                    # create another data.table with all the rows together
                    # (required to compute the median and quartile values)
                    DT_byrows <- data.table::data.table(dplyr::bind_rows(band.tb$time_series))
                    # compute the median and quartile values
                    DT_qts <- create_IQR(DT_byrows, band)
                    # plot the time series together (highlighting the median and quartiles 25% and 75%)
                    plot_samples(DT, DT_qts, band, lb, number)
                })
        })
}

#' @title Plot one timeSeries using ggplot
#'
#' @name .sits_ggplot_series
#'
#' @description Plots a set of time series using ggplot. This function is used
#' for showing the same lat/long location in a series of time steps.
#'
#' @param row         A row of a sits tibble with the time series to be plotted.
#' @param colors      A string with the set of Brewer colors to be used for plotting.
.sits_ggplot_series <- function(row, colors = "Dark2") {
    # create the plot title
    plot_title <- .sits_plot_title(row$latitude, row$longitude, row$label)
    #extract the time series
    data.ts <- row$time_series
    # melt the data into long format
    melted.ts <- data.ts %>%
        reshape2::melt(id.vars = "Index") %>%
        as.data.frame()
    # plot the data with ggplot
    g <- ggplot2::ggplot(melted.ts, ggplot2::aes(x = Index, y = value, group = variable)) +
        ggplot2::geom_line(ggplot2::aes(color = variable)) +
        ggplot2::labs(title = plot_title) +
        ggplot2::scale_color_brewer(palette = colors)
    return(g)
}

#' @title Plot many timeSeries together using ggplot
#'
#' @name .sits_ggplot_together
#'
#' @description Plots a set of  time series together.
#'
#' @param melted.tb   A tibble with the time series (a lot of data already melted).
#' @param means.tb    A tibble with the means and std deviations of the time series.
#' @param plot_title  The title for the plot.
.sits_ggplot_together <- function(melted.tb, means.tb, plot_title) {
    g <- ggplot2::ggplot(data = melted.tb, ggplot2::aes(x = Index, y = value, group = variable)) +
        ggplot2::geom_line(colour = "#819BB1", alpha = 0.5) +
        ggplot2::labs(title = plot_title) +
        ggplot2::geom_line(data = means.tb,
                           ggplot2::aes(x = Index, y = med),  colour = "#B16240", size = 2, inherit.aes = FALSE) +
        ggplot2::geom_line(data = means.tb,
                           ggplot2::aes(x = Index, y = qt25), colour = "#B19540", size = 1, inherit.aes = FALSE) +
        ggplot2::geom_line(data = means.tb,
                           ggplot2::aes(x = Index, y = qt75), colour = "#B19540", size = 1, inherit.aes = FALSE)
    return(g)
}

#' @title Create a plot title to use with ggplot
#' @name .sits_plot_title
#'
#' @description Creates a plot title from row information.
#'
#' @param latitude   Latitude of the location to be plotted.
#' @param longitude  Longitude of the location to be plotted.
#' @param label      Lable of the location to be plotted.
#' @return A string with the title to be used in the plot.
.sits_plot_title <- function(latitude, longitude, label) {
    title <- paste("location (",
                   latitude,  ", ",
                   longitude, ") - ",
                   label,
                   sep = "")
    return(title)
}

#' @title Plot a dendrogram
#' @name .sits_plot_dendrogram
#' @author Rolf Simoes, \email{rolf.simoes@@inpe.br}
#'
#' @description Plot a dendrogram
#'
#' @param data.tb       A sits tibble with data used to extract the dendrogram.
#' @param dendro.obj    Cluster object. Usually stored by `sits_cluster` function in `.sits_last_object`.
#' @param cutree_height A dashed horizontal line to be drawed indicating the height of dendrogram cutting.
#' @param colors        A color scheme as showed in `sits_color_name` function.
.sits_plot_dendrogram <- function(data.tb,
                                 dendro.obj,
                                 cutree_height = NULL,
                                 colors = "RdYlGn"){
    # ensures that a cluster object is informed or exists in .sits_last_cluster global variable.
    ensurer::ensure_that(dendro.obj, !is.null(.),
                         err_desc = "plot_dendrogram: no valid `dendro.obj` informed or found in `.sits_last_cluster`.")

    # get unique labels
    data_labels <- data.tb$label
    uniq_labels <- base::unique(data_labels)

    # warns if the number of available colors is insufficient to all labels
    if (length(uniq_labels) > (length(.sits_brewerRGB[[.sits_color_name(colors)]]) - 1))
        message("sits_plot_dendrogram: The number of labels is greater than the number of available colors.")

    # extract the dendrogram object
    hclust_cl <- methods::S3Part(dendro.obj, strictS3 = TRUE)
    dendrogram <- hclust_cl %>%
        stats::as.dendrogram()

    # prepare labels color vector
    cols <- character(length(data_labels))
    cols[] <- grDevices::rgb(0/255,   0/255,   0/255,   0/255)

    i <- 1
    seq(uniq_labels) %>%
        purrr::map(function(i) {
            cols[data_labels[dendro.obj$order] == uniq_labels[i]] <<- .sits_brewerRGB[[.sits_color_name(colors)]][[length(uniq_labels)]][[i]]
            i <<- i + 1
        })

    # plot the dendrogram
    dendrogram %>%
        dendextend::set("labels", character(length = length(data_labels))) %>%
        dendextend::set("branches_k_color", value = cols, k = length(data_labels)) %>%
        graphics::plot(ylab = paste(tools::file_path_sans_ext(dendro.obj@method),
                                    "linkage distance"))


    # plot cutree line
    if (!is.null(cutree_height)) graphics::abline(h = cutree_height, lty = 2)

    # plot legend
    graphics::legend("topright",
                     fill = as.character(.sits_brewerRGB[[.sits_color_name(colors)]][[length(uniq_labels)]]),
                     legend = uniq_labels)
}

#' @title Plot a raster classified images
#'
#' @name sits_plot_raster
#'
#' @description plots a raster using ggplot. This function is used
#' for showing the same lat/long location in a series of time steps.
#'
#' @param cube        A tibble with the metadata for a labelled data cube.
#' @param time        Temporal reference for plot.
#' @param title       A string.
#' @param colors      Color pallete.
#' @export
sits_plot_raster <- function(cube, time = 1, title = "Classified Image", colors = NULL) {
    #precondition 1 - cube must be a labelled cube
    ensurer::ensure_that(.sits_cube_bands(cube)[1], as.logical(grep("class", (.))),
                         err_desc = "sits_plot_raster: input cube must be a labelled one")
    #precondition 2 - time must be a positive integer
    ensurer::ensure_that(time, (.) >= 1,
                         err_desc = "sits_plot_raster: time must be a positive integer")

    # get the raster object
    r <- .sits_cube_robj(cube, time)

    # convert from raster to points
    map.p <- raster::rasterToPoints(r)
    # create a data frame
    df <- data.frame(map.p)
    # define the column names for the data frame
    colnames(df) <- c("x", "y", "class")

    # get the labels and how many there are
    labels <- .sits_cube_labels(cube)
    nclasses <- length(labels)
    # create a mapping from classes to labels
    names(labels) = as.character(c(1:nclasses))

    # if colors are not specified, get them from the configuration file
    if (purrr::is_null(colors)) {
        colors <- vector(length = nclasses)
        for (i in 1:nclasses)
            colors[i] <- .sits_color(labels[i])
    }
    # set the names of the color vector
    names(colors) <- as.character(c(1:nclasses))

    # plot the data with ggplot
    g <- ggplot2::ggplot(df, ggplot2::aes(x, y)) +
        ggplot2::geom_raster(ggplot2::aes(fill = factor(class))) +
        ggplot2::labs(title = title) +
        ggplot2::scale_fill_manual(values = colors, labels = labels, guide = ggplot2::guide_legend(title = "Classes"))

    return(g)
}

#' @title Plot classification alignments using the dtwSat package
#' @name .sits_plot_twdtw_alignments
#' @author Victor Maus, \email{vwmaus1@@gmail.com}
#' @author Gilberto Camara, \email{gilberto.camara@@inpe.br}
#'
#' @description        Plots the alignments from TWDTW classification (uses dtwSat).
#' @param matches      A list of dtwSat S4 matches objects produced by sits_TWDTW_matches.
.sits_plot_twdtw_alignments <- function(matches){
    # verifies if dtwSat package is installed
    if (!requireNamespace("dtwSat", quietly = TRUE)) {
        stop("dtwSat needed for this function to work. Please install it.", call. = FALSE)
    }

    matches %>%
        purrr::map(function(m.twdtw) {
            dtwSat::plot(m.twdtw, type = "alignments") %>%
                graphics::plot()
        })
    return(invisible(matches))
}

#' @title Plot classification results using the dtwSat package
#' @name .sits_plot_twdtw_classification
#' @author Victor Maus, \email{vwmaus1@@gmail.com}
#' @author Gilberto Camara, \email{gilberto.camara@@inpe.br}
#'
#' @description         Plots the results of TWDTW classification (uses dtwSat).
#' @param  matches      A list of dtwSat S4 matches objects produced by sits_TWDTW_matches.
#' @param  start_date   Start date of the plot (used for showing classifications).
#' @param  end_date     End date of the plot (used for showing classifications).
#' @param  interval     Interval between classifications (used for showing classifications).
#' @param  overlap      Minimum overlapping between one match and the interval of classification. For details see dtwSat::twdtwApply help.
.sits_plot_twdtw_classification <- function(matches,
                                            start_date = NULL, end_date = NULL,
                                            interval = "12 month", overlap = 0.5) {
    # verifies if dtwSat package is installed
    if (!requireNamespace("dtwSat", quietly = TRUE)) {
        stop("dtwSat needed for this function to work. Please install it.", call. = FALSE)
    }

    matches %>%
        purrr::map(function(m.twdtw) {
            if (purrr::is_null(start_date) | purrr::is_null(end_date))
                dplot <- dtwSat::plot(m.twdtw, type = "classification", overlap = 0.5)
            else
                dplot <- dtwSat::plot(m.twdtw, type = "classification", from = start_date,
                                       to = end_date, by = interval, overlap = overlap)
            graphics::plot(dplot)

        })
    return(invisible(matches))
}

#' @title Plot matches between a label pattern and a time series using the dtwSat package
#' @name .sits_plot_twdtw_matches
#' @author Victor Maus, \email{vwmaus1@@gmail.com}
#' @author Gilberto Camara, \email{gilberto.camara@@inpe.br}
#'
#' @description Plots the matches from TWDTW classification for one label.
#'
#' @param matches       A list of dtwSat S4 matches objects produced by sits_TWDTW_matches.
#' @param patterns.tb   A set of known temporal signatures for the chosen classes.
#' @param n_matches     Number of matches of a given label to be displayed.
.sits_plot_twdtw_matches <- function(matches, patterns.tb, n_matches = 4) {
    matches %>%
        purrr::map(function(m.twdtw) {
            dtwSat::plot(m.twdtw, type = "matches", patterns.labels = patterns.tb$label, k = n_matches) %>%
                graphics::plot()
        })
    return(invisible(matches))
}
